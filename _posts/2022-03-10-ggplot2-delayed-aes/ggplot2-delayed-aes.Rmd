---
title: "Demystifying delayed aesthetic evaluation"
description: |
  An introduction to `stage()`, `after_stat()`, and `after_scale()` with {ggtrace}
categories:
  - data visualization
  - ggplot2
  - tutorial
base_url: https://yjunechoe.github.io
author:
  - name: June Choe
    affiliation: University of Pennsylvania Linguistics
    affiliation_url: https://live-sas-www-ling.pantheon.sas.upenn.edu/
    orcid_id: 0000-0002-0701-921X
date: "`r Sys.Date()`"
output:
  distill::distill_article:
    toc: true
    self_contained: false
    css: "../../styles.css"
editor_options: 
  chunk_output_type: console
draft: true
---

```{r setup, include=FALSE}
library(knitr)
ragg_png = function(..., res = 150) {
  ragg::agg_png(..., res = res, units = "in")
}
opts_chunk$set(
  comment = " ",
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  dev = "ragg_png",
  R.options = list(width = 80)
)
```


## Setup

```{r, message = FALSE}
library(ggtrace)
library(ggplot2)
library(dplyr)
library(purrr)

penguins <- na.omit(palmerpenguins::penguins)
rmarkdown::paged_table(penguins)
```

## Motivating example: `geom_bar()`

The `geom_bar()` layer requires an `x` _or_ `y` aesthetic, and maps a new variable called `count` to the "un-used" of the two. In other words, if you give it a discrete variable, it will derive the count of each category in that variable and use that information to determine bar height.

So depending on whether the variable to be counted is mapped to the `x` or `y` aesthetic, the bars appear upright (count by categories of x) or flipped (count by categories of y):

```{r, out.width="50%", fig.show="hold"}
ggplot(penguins) +
  geom_bar(aes(x = species))

ggplot(penguins) +
  geom_bar(aes(y = species))
```

But note that there is no variable/column called `count` from our original `penguins` dataframe:

```{r}
"count" %in% colnames(penguins)
```

So where exactly does this `count` variable come from? More specifically...

1. Where and how is the new variable `count` _computed_?
2. Where and how is the computed variable `count` _mapped_? 

## Much of ggplot is "delayed evaluation"

To answer these questions, we need to take a detour and first make a distinction between "defining" a ggplot and "rendering" a ggplot.

Most of what we do when we write code and "combine layers" like `geom_*()`, `stat_*()`, `facet_*()`, etc. with the `+` operator is actually providing pieces of **instructions** for making the plot. Essentially, ggplot "collects" the plot specifications strung together with `+` and organizes them following a _standardized blueprint_ underlying all ggplot objects.^[The _standardized_ part of this is what supports the large ecosystem of extension packages that integrate smoothly with {ggplot2} itself. For a less practical (but conceptually exciting) consequence of this design, check out the proof-of-concept package [{ggreverse}](https://github.com/coolbutuseless/ggreverse) which generates (back-forms) ggplot code from a ggplot object.]

This design of ggplot internals is what allows you to swap the order of a facet with a geom without consequences to the plot's appearance, for example. The internal blueprint ensures that the Facet will always step in to split up the data by panels _before_ the Stat and Geom step in to transform the data and make graphical objects.

```{r, out.width="50%", fig.show="hold"}
ggplot(penguins) +
  facet_wrap(~ island) +
  geom_bar(aes(x = species))

ggplot(penguins) +
  geom_bar(aes(x = species)) +
  facet_wrap(~ island)
```

In this sense, the ggplot2 interface is said to have **declarative** semantics. Your code makes statements like "... this plot should be facetted by `island`", rather than "... and now facet the plot by `island`."^[The distinction clicked for me personally after reading the classic [sandwich example](https://mastering-shiny.org/basic-reactivity.html#imperative-vs-declarative-programming), which I first came across when learning Shiny (another declarative system).] This distinction may be subtle but it's an integral part of what makes the "Grammar of Graphics" a _grammar_.^[In a [recent interview](https://youtu.be/rE062dA-pT4?t=1888) with Leland Wilkinson (may he rest in peace), he tells a story of how Tableau used to erroneously apply scale transformations faithful to the _user's_ order of execution, instead of the order dictated by the _grammar_, which led to two "geoms" (points and a regression line) being drawn with different scales - the points in log space and the regression line in untransformed "identity" space. This is "ungrammatical" and thus rightly forbidden in ggplot - if multiple scales are specified for the same aesthetic, ggplot will resolve the conflict by just settling on the last scale with a warning _before_ computing or drawing anything.] The most significant consequence of this separation of defining a ggplot vs. rendering a ggplot is that you can continuously add new elements to a plot without needing to go back and redraw the plot each time.

Then when does the ggplot actually get "rendered"?^[Strictly speaking, it's `{grid}` that does the rendering with `grid::grid.newpage()` and `grid::grid.draw()`, but I'll follow the [ggplot2 book](https://ggplot2-book.org/internals.html#the-plot-method) in using the term "rendering" here to refer to the step that takes you from the data + the plot specifications to a transformed data that is drawing-ready.] It happens when the ggplot is printed/plotted, as defined in the S3 methods `ggplot2:::plot.ggplot` and `ggplot2:::print.ggplot` (they're the same thing).

And as we might expect, defining a ggplot is quick and cost-less but rendering it takes some time:

```{r}
system.time({
  p <- ggplot(penguins) +
    aes(x = species) +
    aes(fill = species) +
    geom_bar()
})
system.time({
  print(p)
})
```

The bulk of the work in the print/plot method of ggplot is done by functions `ggplot_build()` and `ggplot_gtable()`, which converts the raw data to a transformed data that are relevant for drawing, and then makes graphical objects using that data, respectively. This happens in Steps 5 and 6 of the print/plot method for ggplot.

```{r}
as.list(body(ggplot2:::print.ggplot))[5:6]
```

So why do I bring up this high-level description of ggplot internals? Well it's at this print/plot step of a ggplot object's **execution** when the original data is **augmented** with internally-computed variables.

## In search of `count`

Since the `count` variable from `geom_bar()` is calculated during the execution of the ggplot, it must be from one of the two workhorses of the rendering step: `ggplot_build()` or `ggplot_gtable()`. Generally speaking, `ggplot_build()` deals with the dataframe representation of the plot (e.g., mutating variables/columns), and `ggplot_gtable()` deals with the graphical object representation of the plot (e.g., adding facet labels/strips to panels), so we expect the `count` variable to appear inside the `ggplot_build()` step.

Let's inspect how the plotting data (stored in the internal variable called `data`) gets transformed inside `ggplot_build()`, using the `ggtrace_inspect_vars()` function from `{ggtrace}` which returns a list containing a snapshot of a variable(s)'s value whenever it changed:

```{r}
internal_data_transformations <- ggtrace_inspect_vars(
  x = p,
  method = ggplot2:::ggplot_build.ggplot,
  vars = "data"
)
length(internal_data_transformations)
```

In the course of evaluating our ggplot `p`, the dataframe representation of the layers changed ten times. The first and last snapshots of `data` are equal to the original data and the `{grid}`-ready data that's shipped off to `ggplot_gtable()`, respectively. Thus, the first snapshot is the same as our `penguins` dataframe and the last snapshot is the same as the output of `layer_data(p, 1)`.

```{r}
# Note that `data` is actually a list of dataframes,
# with each element corresponding to a layer
# - e.g., data for first layer is `data[[1]]`
internal_data_transformations[[1]]
internal_data_transformations[[10]]

# Checking for equality
identical(
  penguins,
  internal_data_transformations[[1]][[1]]
)
identical(
  layer_data(p, 1),
  internal_data_transformations[[10]][[1]]
)
```

By the time we reach the last snapshot of `data`, the `count` variable is present in the first layer `data[[1]]`:

```{r}
internal_data_transformations[[10]]
```

Conveniently, `ggtrace_inspect_vars()` also returns the Steps where the change to a variable's value was detected. These are stored as names of the returned list:

```{r}
names(internal_data_transformations)
```

Check out the full output of `ggtrace_inspect_vars()` to inspect the state of the data for the first layer every time it changed, as well as the preceding call that's responsible for that change:

```{r, layout="l-page", echo = FALSE}
library(htmltools)
library(reactable)
idf <- map(internal_data_transformations, 1)
div(
  style = "padding: 1rem 1rem 0 1rem; border: 1px solid black;",
  map2(idf, names(idf), ~ {
    tags$details(
      tags$summary(.y),
      tags$div(
        tags$strong("Preceding step: ", style = "padding-left:5px;"),
        tags$pre(
          style = "font-family: 'Fira Mono'; padding-left: 15px; background-color: white;",
          paste(deparse(ggbody(ggplot2:::ggplot_build.ggplot)[[as.numeric(gsub("(.*?)(\\d+)$", "\\2", .y)) - 1L]]), collapse = "\n")
        )
      ),
      tags$div(
        tags$div(tags$strong("Value at current step:", style = "padding-left:5px;"), style = "margin-bottom: -10px;"),
        reactable(
          .x,
          bordered = TRUE,
          resizable = TRUE,
          wrap = FALSE,
          style = ""
        )
      )
    )
  }))
```


