---
title: "Demystifying delayed aesthetic evaluation: Part 2"
description: |
  Exposing the `Stat` ggproto in functional programming terms
categories:
  - data visualization
  - ggplot2
  - tutorial
base_url: https://yjunechoe.github.io
author:
  - name: June Choe
    affiliation: University of Pennsylvania Linguistics
    affiliation_url: https://live-sas-www-ling.pantheon.sas.upenn.edu/
    orcid_id: 0000-0002-0701-921X
date: "`r Sys.Date()`"
output:
  distill::distill_article:
    toc: true
    self_contained: false
    css: "../../styles.css"
editor_options: 
  chunk_output_type: console
draft: true
---

```{r setup, include=FALSE}
ragg_png = function(..., res = 150) {
  ragg::agg_png(..., res = res, units = "in")
}
knitr::opts_chunk$set(
  comment = " ",
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  dev = "ragg_png",
  R.options = list(width = 80)
)
```

_This is a developing series of blog posts, scheduled for three parts:_

- _[Part 1: Exploring the logic of `after_stat()` to peek inside ggplot internals](https://yjunechoe.github.io/posts/2022-03-10-ggplot2-delayed-aes-1)_
- _[Part 2: Exposing the `Stat` ggproto in functional programming terms]()_ (you are here)
- _Part 3: Completing the picture with `after_scale()` and `stage()`_ (TBD)

## Introduction

Let's pick up where we left off in [Part 1](https://yjunechoe.github.io/posts/2022-03-10-ggplot2-delayed-aes-1). If you'd like to follow along without going back to re-read it, the relevant code that we'll carry over here is provided below:

<details>
<summary>Setup from Part 1</summary>

```{r setup}
# Top-level setup
library(ggplot2)
library(dplyr)
library(palmerpenguins)
theme_set(theme_classic(14))

# Custom function to inspect `after_stat()`
inspect_after_stat <- function(p, i = 1L) {
  ._env <- environment()
  .out <- NULL
  suppressMessages({
    trace(
      what = "ggplot_build.ggplot",
      tracer = substitute(assign(".out", data[[i]], envir = ._env), ._env),
      at = 19L,
      print = FALSE,
      where = asNamespace("ggplot2")
    )
  })
  ggplot_build(p)
  suppressMessages({
    untrace("ggplot_build.ggplot", where = asNamespace("ggplot2"))
  })
  .out
}
```

</details>

To recap, the big theme of [Part 1](https://yjunechoe.github.io/posts/2022-03-10-ggplot2-delayed-aes-1) was about how _each layer_ of a ggplot transforms the raw data under the hood to make it _"drawing ready"_ (i.e., the dataframe returned by `layer_data()`). We saw that a lot happens over the course of this data transformation pipeline, one of which is the **statistical transformation step**. For example, the `geom_bar()` layer uses `stat = "count"` by default, which computes new variables like `count` and `prop` internally.

We also saw how `after_stat()` allows users to declare a **delayed aesthetic mapping**, which waits to be applied until after this statistical transformation step. For example, the specific stat used by `geom_bar()` - `StatCount` (which the `"count"` stands for in `stat = "count"`) - does maps to `after_stat(count)` by default, implicitly.

<details>
<summary>How is the implicit `after_stat(count)` mapping implemented in `StatCount`?</summary>

    First, the default aesthetic mappings are specified such that _both_ `x` and `y` are mapped to `after_stat(count)`
    
    ```{r statcount-default-aes}
    # or `geom_bar()$stat$default_aes`
    StatCount$default_aes
    ```


    
    ```{r statcount-required-aes}
    # or `geom_bar()$stat$required_aes`
    StatCount$required_aes
    ```

    So by requiring the user to supply one of the two aesthetics, the leftover of the two takes on the "implicit" value of `after_stat(count)`. This is (mostly but not entirely) handled inside `StatCount$setup_params` which is called pretty early in the pipeline:
    
    ```{r statcount-setup-params}
    # Lots of code here but it does 3 things:
    # 1) Check if user supplied `y`, not `x` (+ track this in `flipped_aes`)
    # 2) Make sure user supplied exactly one of `x` or `y`
    # 3) If `flipped_aes` (= `y` is supplied), pretend that it's `x` but
    #    keep that for later (reverted in `StatCount$compute_group()`)
    StatCount$setup_params
    ```
</details>

In this Part 2 of the series, we'll dig into the nitty-gritty details of the internal statistical transformation step. Along the way, we'll encounter some funny looking functions in the form of `obj$method()`. These are called **ggproto methods** - they're pretty scary ([you can judge for yourself](https://ggplot2-book.org/internals.html#introducing-ggproto)), but needlessly so for our purposes: aside from their odd syntax, most of them are essentially just data wrangling functions.

Let's dive right in!

## Another bar plot

We're again going to visualize counts of penguin species in our `penguins` dataset with `geom_bar()`, except this time we'll give the bars `width = 0.7` and also facet by island:

```{r p-bar-facetted, eval=FALSE}
library(palmerpenguins)
p_bar_facetted <- ggplot(penguins, aes(x = species)) +
  geom_bar(aes(fill = species), width = 0.7) +
  facet_wrap(~ island)
p_bar_facetted
```

As expected, it maps the internally computed `count` variable to the `y` aesthetic by default. We suspect that something like `{dplyr}`'s `group_by()` and `summarize()` (or just `count()`) is happening in the statistical transformation stage:

```{r dplyr-compute}
penguins %>% 
  group_by(island, species) %>% 
  summarize(count = n(), .groups = "drop")
```

In [Part 1](), I introduced this mystery function called `inspect_after_stat()` to show you that this is indeed the case:

```{r custom-inspect-after-stat}
inspect_after_stat(p_bar_facetted, i = 1)
```

Now it's time to unveil the mystery behind this function - it was essentially giving us the return value of the ggproto method `Stat$compute_layer()` when it was called for the first layer of our plot.^[So `i = 1` was targetting our one and only layer, `geom_boxplot()`.]

Using the function `ggtrace_inspect_return()` from my package [`{ggtrace}`](https://yjunechoe.github.io/ggtrace/articles/intro.html), we can achieve this more explicitly. We pass the function our plot and the ggproto method we want to inspect, and it gives us what the method returned:

```{r inspect-return-layer}
# install.packages("remotes")
# remotes::install_github("yjunechoe/ggtrace")
library(ggtrace)
compute_layer_output <- ggtrace_inspect_return(p_bar_facetted, method = Stat$compute_layer)
compute_layer_output
```

If ggproto methods are like functions, they should have inputs and outputs. We just saw the output of `Stat$compute_layer()`, but what's its input?

We can simply swap out `ggtrace_inspect_return()` with `ggtrace_inspect_args()` to look at the arguments it was called with:

```{r inspect-args-layer}
compute_layer_input <- ggtrace_inspect_args(p_bar_facetted, method = Stat$compute_layer)
names( compute_layer_input )
```

We see that it was called with several arguments, but we can ignore the `self` and `layout` arguments for the moment. The crucial ones are the `data` and `params` arguments, which look like this:

```{r inspect-args-layer, eval=FALSE}
compute_layer_input$data
```

```{r inspect-args-layer-paged, echo=FALSE}
rmarkdown::paged_table(compute_layer_input$data)
```

```{r inspect-args-layer}
compute_layer_input$params
```

Remember how I said ggproto methods are essentially data-wrangling functions? 



For example, remember the `inspect_after_stat()` function introduced in [Part 1](https://yjunechoe.github.io/posts/2022-03-10-ggplot2-delayed-aes-1)?

```{r}
inspect_after_stat(p_bar)
```

As a sneak peek, that function was essentially grabbing the output of the `Stat$compute_layer()` ggproto method. We can do this more explicitly and dynamically with the function `ggtrace_inspect_return()` from my package [`{ggtrace}`](https://yjunechoe.github.io/ggtrace/articles/intro.html). We pass it our plot and the ggproto method we want to inspect, and it gives us back what it returns:

```{r}
ggtrace_inspect_return(p_bar, method = Stat$compute_layer)
```

As the name suggests, internally computed variables like `count` and `prop` are calculated inside the `Stat$compute_layer()` method. It might look scary but it's actually just a data wrangling function. As a sneak peek, this is the input data to the stat stage:

```{r}
rmarkdown::paged_table(ggtrace_inspect_args(p_bar, method = Stat$compute_layer)$data)
```


As the name suggests, the `compute_layer()` method computes the variables necessary to draw the layer. 


We're going to encounter these things called ggproto methods in the way


and expose it in familiar functional programming terms. We'll work through the **What** (what are the inputs/outputs involved), and the **How** (how output is computed from the input). 

In doing so, we'll learn that...

1. Much of the work required for _rendering_ a ggplot2 (computation, drawing) happens _after_ the plot is defined

2. ggproto objects are essentially _lists_, and ggproto methods are essentially _functions_

Let's dive in!


### Where it all happens: the `compute_statistic()` method

If you got a chance to peak inside the collapsible details where `inspect_after_stat()` was defined in [Part 1](), you would have seen how the function was taking a snapshot of the internal variable `data` right after this line runs inside `ggplot_build()`:

```{r}
body(ggplot2:::ggplot_build.ggplot)[[18L]]
```

We don't have to understand what `ggplot_build()` or `by_layer()` is (yet!). In plain English, what happens in this line is that this function called `l$compute_static()` **applies the statistical transformation to the data associated with each layer, according to each layer's special instructions for doing so**.

If you're wondering about the `l$` part of `l$compute_static()`, the `l` represents a `Layer` object created by `geom_*()` and `stat_*()` functions. You can read a bit more on this in the collapsible below:

<details>
<summary> Quick aside on `Layer` </summary>

A ggplot object is essentially a list:

```{r}
typeof( unclass(p_bar) )
```

One of the elements in this list is called `layers`, and it contains all layers of a plot:

```{r}
p_bar$layers
```

We often add layers to a ggplot with `+`, like this:

```{r}
p_bar_text <- p_bar + 
  geom_text(
    aes(y = after_stat(count), label = after_stat(count)),
    stat = "count", vjust = -0.4
  )

p_bar_text
```

This essentially _updates_ the `layers` element via appending^[For full details, see `ggplot2:::ggplot_add.Layer`.
]:

```{r}
p_bar_text$layers
```

Each element of `layers` are `Layer` objects, which themselves are also [essentially lists](https://adv-r.hadley.nz/environments.html?#env-basics). The `compute_statistic()` function is simply one of the elements that live inside `Layer`, which we can reference with `ggplot2:::Layer$compute_statistic`:

```{r}
ggplot2:::Layer$compute_statistic
```

So, for now, whenever you see a piece of code in the form `{left}${right}()`, just think of the left-hand side as a **list** and the right-hand side as a **function**.

In fact, 99% of ggplot internals is calling functions (ggproto methods) that are bundled up together in lists (ggproto objects). This is what ggproto boils down to if you remove the "gg" and the "proto" part of the "ggproto":

```{r}
Number <- list(
  add = function(x, y) { x + y },
  subtract = function(x, y) { x - y }
)
Number$add(1, 2)
Number$subtract(12, 1)

String <- list(
  add = function(x, y) { paste0(x, y) },
  subtract = function(x, y) { gsub(y, "", x) }
)
String$add(1, 2)
String$subtract("12", "1")
```

In the toy example above, the _grammar_ specifies abstract operations like `add` and `subtract`, and the implementational details are left to _objects_ like `Number` and `String`.

</details>

Okay, so `l$compute_statistic()` or `Layer$compute_statistic()` (or `compute_statistic` for short) is a function that does the statistical transformation, but what is its input and output?



For example, in the case of our `p_bar` example from [Part 1](), this function `compute_static` applies the statistical transformation according to the **stat** of our bar layer (`stat = "count"`), as well as some other parameters like `width`, which takes the default value of `0.9`. That's where `count`, `prop`, and `width` comes from:

```{r}
inspect_after_stat(p_bar, i = 1L)
```





```{r}
inspect_before_stat <- function(p, i = 1L) {
  ._env <- environment()
  .out <- NULL
  suppressMessages({
    trace(
      what = "ggplot_build.ggplot",
      tracer = substitute(assign(".out", data[[i]], envir = ._env), ._env),
      at = 18L,
      print = FALSE,
      where = asNamespace("ggplot2")
    )
  })
  ggplot_build(p)
  suppressMessages({
    untrace("ggplot_build.ggplot", where = asNamespace("ggplot2"))
  })
  .out
}
```


## Setup

```{r, message = FALSE}
library(ggtrace)
library(ggplot2)
library(dplyr)

penguins <- na.omit(palmerpenguins::penguins)
rmarkdown::paged_table(penguins)
```

## Motivating example: `geom_bar()`

The `geom_bar()` layer requires an `x` _or_ `y` aesthetic, and maps a new variable called `count` to the "un-used" of the two. In other words, if you give it a discrete variable, it will derive the count of each category in that variable and use that information to determine bar height.

So depending on whether the variable to be counted is mapped to the `x` or `y` aesthetic, the bars appear upright (count by categories of x) or flipped (count by categories of y):

```{r, out.width="50%", fig.show="hold"}
ggplot(penguins) +
  geom_bar(aes(x = species))

ggplot(penguins) +
  geom_bar(aes(y = species))
```

But note that there is no variable/column called `count` from our original `penguins` dataframe:

```{r}
"count" %in% colnames(penguins)
```

So where exactly does this `count` variable come from? In this two-part blog post

1. Where and how is the computed variable `count` _mapped_?

2. Where and how is the new variable `count` _computed_?


## Much of ggplot is "delayed evaluation"

To answer these questions, we need to take a detour and first make a distinction between "defining" a ggplot and "rendering" a ggplot.

Most of what we do when we write code and "combine layers" like `geom_*()`, `stat_*()`, `facet_*()`, etc. with the `+` operator is actually providing pieces of **instructions** for making the plot. Essentially, ggplot "collects" the plot specifications strung together with `+` and organizes them following a _standardized blueprint_ underlying all ggplot objects.^[The _standardized_ part of this is what supports the large ecosystem of extension packages that integrate smoothly with `{ggplot2}` itself. For a less practical (but conceptually exciting) consequence of this design, check out the proof-of-concept package [`{ggreverse}`](https://github.com/coolbutuseless/ggreverse) which generates (back-forms) ggplot code from a ggplot object.]

This design of ggplot internals is what allows you to swap the order of a facet with a geom without consequences to the plot's appearance, for example. The internal blueprint ensures that the Facet will always step in to split up the data by panels _before_ the Stat and Geom step in to transform the data and make graphical objects:

```{r, out.width="50%", fig.show="hold"}
ggplot(penguins) +
  facet_wrap(~ island) +
  geom_bar(aes(x = species))

ggplot(penguins) +
  geom_bar(aes(x = species)) +
  facet_wrap(~ island)
```

As another case in point, we can save the output of layer functions to a variable, and add that to two different ggplots. Here, although `geom_bar_obj` causes different bars to be drawn between the two plots, it's "doing the same thing" of carrying out the instruction to count up by categories of `x` and mapping the count to `y`:

```{r, out.width="50%", fig.show="hold"}
geom_bar_obj <- geom_bar()

ggplot(penguins) + 
  aes(x = species) +
  geom_bar_obj

ggplot(penguins) +
  aes(x = island) +
  geom_bar_obj
```


In this sense, the ggplot2 interface is said to have **declarative** semantics. Your code makes statements like "... this plot should be facetted by `island`", rather than "... and now facet the plot by `island`."^[The distinction clicked for me personally after reading the classic [sandwich example](https://mastering-shiny.org/basic-reactivity.html#imperative-vs-declarative-programming), which I first came across when learning Shiny (another declarative system).] This distinction may be subtle but it's an integral part of what makes the "Grammar of Graphics" a _grammar_.^[In a [recent interview](https://youtu.be/rE062dA-pT4?t=1888) with Leland Wilkinson (may he rest in peace), he tells a story of how Tableau used to erroneously apply scale transformations faithful to the _user's_ order of execution, instead of the order dictated by the _grammar_, which led to two "geoms" (points and a regression line) being drawn with different scales - the points in log space and the regression line in untransformed identity space. This is "ungrammatical" and thus rightly forbidden in ggplot - if multiple scales are specified for the same aesthetic, ggplot will resolve the conflict by just settling on the last scale with a warning _before_ computing or drawing anything.] The most significant consequence of this separation of defining a ggplot vs. rendering a ggplot is that you can continuously add new elements to a plot without needing to go back and redraw the plot each time.

Then when does the ggplot actually get "rendered"?^[Strictly speaking, it's `{grid}` that does the rendering with `grid::grid.newpage()` and `grid::grid.draw()`, but I'll follow the [ggplot2 book](https://ggplot2-book.org/internals.html#the-plot-method) in using the term "rendering" here to refer to the step that takes you from the data + the plot specifications to a transformed data that is drawing-ready.] It happens when the ggplot is printed/plotted, as defined in the S3 methods `ggplot2:::plot.ggplot` and `ggplot2:::print.ggplot` (they're the same thing). Take a quick look at the function body below:

<details>
<summary>ggplot2 print/plot method</summary>
```{r}
body(ggplot2:::print.ggplot)
identical(
  body(ggplot2:::print.ggplot),
  body(ggplot2:::plot.ggplot)
)
```

</details>

As we might expect, a quick benchmark test reveals that defining a ggplot (with user-facing code) is quick and cost-less while rendering it (via the print/plot method) takes some time:^[A quick caveat: things still get evaluated in the step of defining a ggplot. After all, the `+` infix is an operator/function (more specifically, it's [a method of `+` for class `<gg>`](https://github.com/tidyverse/ggplot2/blob/87e9b85dd9f2a294f339d88a353d0c11c851489d/R/plot-construction.r#L24-L56). This is an example of what's called [operator overloading](https://www.techopedia.com/definition/24294/operator-overloading), and while it's popular in other languages, Hadley himself [regrets](https://youtu.be/vYwXMnC03I4?t=325) using the `+` instead of the pipe in the design of ggplot2), and layers like `geom_*()` and `stat_*()` are functions that get called on the spot with the parantheses `()`. But the computation that goes on during the "definition" step mostly deals with making the instructions conform to the standardized blueprint (e.g., resolving conflicting scales), and is thus relatively costless. But of course, this doesn't _have_ to be the case: there are extension packages like [{gghighlight}](https://yutannihilation.github.io/gghighlight/) which add [more functionalities to the `+`](https://github.com/yutannihilation/gghighlight/blob/4bc54b152796a0631c6557ef936c328bcbf9b5b9/R/gghighlight.R#L108-L229). ]

```{r}
system.time({
  p <- ggplot(penguins) +
    aes(x = species) +
    aes(fill = species) +
    geom_bar()
})
system.time({
  print(p)
})
```

The bulk of the work in the print/plot method of ggplot is done by functions `ggplot_build()` and `ggplot_gtable()`, which converts the raw data to a transformed data that contains variables relevant for drawing, and then makes graphical objects using that data, respectively. This happens in Steps 5 and 6 of the print/plot method for ggplot, repeated below:

```{r}
as.list(body(ggplot2:::print.ggplot))[5:6]
```

So why do I bring up this high-level overview of ggplot internals? Well it's at this print/plot step of a ggplot object's **execution** when the original data is **augmented** with internally-computed variables like `count` from `geom_bar()`.

Again, the common theme here is **delayed evaluation**. Keep this in mind as we continue working through our `geom_bar()` example.

## The _When_ - in search of `count`

We have good reasons to think that the `count` variable from `geom_bar()` was calculated during the execution of the ggplot, in which case it must be from one of the two workhorses of the rendering step: `ggplot_build()` and `ggplot_gtable()`.

Generally speaking, `ggplot_build()` deals with the dataframe representation of the plot layers (e.g., mutating variables/columns), and `ggplot_gtable()` deals with the graphical object representation of the plot components (e.g., adding facet labels/strips to panels). So we expect the `count` variable to appear inside the `ggplot_build()` step.

Take a quick skim at what `ggplot_build()` looks like if you aren't familiar. There's a lot going on here, but what should stand out is the repeated assignment to this internal variable called `data`. This looks very much like our familiar data-wrangling workflow, minus the pipe!

<details>
<summary>Body of `ggplot_build()`</summary>
Note that `ggplot_build()` is actually what's called a <a href="https://adv-r.hadley.nz/s3.html#s3-methods">_generic_</a>, much like `print()` and `plot()`, so we have to look at the method as defined for the `<ggplot>` class:
```{r}
# S3 Generic
body(ggplot2::ggplot_build)
# Method for class <ggplot>
body(ggplot2:::ggplot_build.ggplot)
```
</details>

Let's inspect how the plotting data (stored in the internal variable called `data`) gets transformed inside `ggplot_build()`, using the `ggtrace_inspect_vars()` function from `{ggtrace}` which returns a list containing a snapshot of a variable(s)'s value **every time it changes**:

```{r}
internal_data_transformations <- ggtrace_inspect_vars(
  x = p,
  method = ggplot2:::ggplot_build.ggplot,
  vars = "data"
)
length(internal_data_transformations)
```

In the course of evaluating our ggplot `p`, the dataframe representation of the layers **changed ten times**. The first snapshot is the same as our `penguins` dataframe (the original data) and the last snapshot is the same as the output of `layer_data(p, 1)` (the `{grid}`-ready data that's shipped off to `ggplot_gtable()`).^[If you aren't familiar with the `layer_data()` function, I introduce it in a [previous blog post on stat layers](https://yjunechoe.github.io/posts/2020-09-26-demystifying-stat-layers-ggplot2/).]

```{r}
# Note that `data` is actually a list of dataframes,
# with each element corresponding to a layer.
# - e.g., data for first layer is `data[[1]]`
internal_data_transformations[c(1, 10)]
```

By the time we reach the last snapshot of `data`, we see that the `count` variable is present in our plot's first (and only) layer, in `data[[1]]`:

```{r}
internal_data_transformations[[10]]
```

But what _code_ is responsible for introducing this new `count` variable?

As you saw briefly above, the names of the list returned by `ggtrace_inspect_vars()` record the **Steps** in the method body where changes were detected:

```{r}
names(internal_data_transformations)
```

Check out the full output of `ggtrace_inspect_vars()` below to inspect the state of the data for the first layer `data[[1]]` every time it changed, as well as the preceding call that's responsible for that change. Don't try to understand the logic behind each data transformation step, but do appreciate the fact that these transformations can be understood in familiar data-wrangling/{dplyr} terms!

If you need more guidance, focus on answering these two questions:

- When does `count` first appear in the data frame?
- When does the value of `y` become equal to the value of `count`?

```{r, layout="l-body-outset", echo = FALSE}
library(purrr)
library(htmltools)
library(reactable)
idf <- map(internal_data_transformations, 1)
div(
  style = "padding: 1rem 1rem 0 1rem; border: 1px solid black;",
  map2(idf, names(idf), ~ {
    tags$details(
      tags$summary(.y),
      tags$div(
        tags$strong("Preceding step: ", style = "padding-left:5px;"),
        tags$pre(
          style = "font-family: 'Fira Mono'; padding-left: 15px; background-color: white;",
          paste(deparse(ggbody(ggplot2:::ggplot_build.ggplot)[[as.numeric(gsub("(.*?)(\\d+)$", "\\2", .y)) - 1L]]), collapse = "\n")
        )
      ),
      tags$div(
        tags$div(tags$strong("Value of ", tags$code("data[[1]]"), " at current step:", style = "padding-left:5px;"), style = "margin-bottom: -10px;"),
        reactable(
          .x,
          bordered = TRUE,
          resizable = TRUE,
          wrap = FALSE,
          style = ""
        )
      )
    )
  }))
```

<br>

Are you ready for the answers?

The `count` column is first added to the data by this line:

```{r}
body(ggplot2:::ggplot_build.ggplot)[[18]]
```

Then, the `y` column is created with the same value as `count` by this line:

```{r}
body(ggplot2:::ggplot_build.ggplot)[[19]]
```

The functions `compute_statistic` and `map_statistic` that you see above are called **methods**. Specifically, they are **ggproto methods** of the **ggproto** object `Layer`.

The `Layer` ggproto is actually not crucial to our story, but if you'd like to understand it better you can read a bit more below:

<details>
<summary>An aside on the `Layer` ggproto</summary>
A `Layer` is an object returned by `ggplot2::layer()`. You don't see that function often, but it's what gets called by `geom_*()` and `stat_*()` functions, so you've actually seen this a lot.

For example, if you call `geom_bar()` on its own, you'll get back an object of class `LayerInstance`/`Layer`

```{r}
geom_bar()
class(geom_bar())
```

The body of `geom_bar()` just calls `ggplot::layer()` with some defaults optimized for drawing bar plots.

```{r}
body(geom_bar)
```

So these two are practically the same:

```{r}
geom_bar()
layer(
  geom = GeomBar, stat = StatCount, position = PositionStack,
  params = list(width = NULL, na.rm = FALSE, orientation = NA)
)
```

These `Layer` objects have various "methods" (functions) and "properties" (non-functions), such as `compute_statistic`.

```{r}
sapply(as.list(geom_bar()), is.function)
```

The `compute_statistic` method is defined in the `Layer` ggproto, which is unexported. The `LayerInstance` ggproto class returned by `geom_bar()` simply inherits this method from the parent `Layer` ggproto:

```{r}
inherits(geom_bar(), "Layer")
get_method_inheritance(geom_bar())
```

The `Layer` ggproto is unexported, so you need to use the `:::` to grab it first when inspecting its methods.

```{r}
ggplot2:::Layer$compute_statistic
```

Note that `base::body()` does not work for ggproto methods out of the box:

```{r}
body(ggplot2:::Layer$compute_statistic)
```

Thus, we'll use the `ggbody()` function from the `{ggtrace}` package moving forward:

```{r}
ggtrace::ggbody(ggplot2:::Layer$compute_statistic, as.list = FALSE)
```
</details>

So we've figured out "when" things happen. Let's now move on to explore "what" exactly happens in these steps

## The _What_ - computation by the Stat

### 1. Inspecting `Layer$compute_statistics`

The `compute_statistics` method of the `Layer` ggproto looks like the following:

```{r}
ggtrace::get_method(ggplot2:::Layer$compute_statistic)
```

As the name suggests, the `compute_statistics` method calls several methods from the `Layer`'s (`self`'s) [`Stat` ggproto](https://ggplot2.tidyverse.org/reference/ggplot2-ggproto.html#stats).

In the case of `geom_bar()`, the specific `Stat` ggproto is the `StatCount` ggproto by default. By the same token, the `self$stat` inside the `Layer$compute_statistic` method is evalauted as `StatCount`.

```{r}
class(geom_bar()$stat)
inherits(StatCount, "Stat")
```

The most important piece of `Layer$compute_statistic` is the call to `self$stat$compute_layer` in the last line, which, again, evaluates to `StatCount$compute_layer` for the bar layer. This method is responsible for adding the `count` column, among other things, to the dataframe representation of our bar layer - let's see how.

### 2. Inspecting the Stat's `compute_*` methods

An internal design of `Stat` ggprotos that is not transparent but nevertheless very important is that they come with a family of _compute_ methods - `compute_layer`, `compute_panel`, and `compute_group` - which are called once per layer, panel, and group, respectively. 

```{r}
grep("^compute_", names(Stat), value = TRUE)
```

Specifically, `StatCount` inherits the `compute_layer` and `compute_panel` methods from the parent `Stat` ggproto but uses its own `compute_group` method:

```{r}
lapply(get_method_inheritance(StatCount), grep, pattern = "^compute_", value = TRUE)
```

Let's revisit our bar plot which we haven't seen in a while. How do we know how many layers, panels, and groups there are?

```{r}
p
```

We can get the layers of a ggplot by subsetting the `layers` element of the plot. Here, we see that we have one layer, created by `geom_bar()`:

```{r}
p$layers
```

We can get the panels and groups involved in a layer using `layer_data()` and inspecting the columns `PANEL` and `group`. For our first (and only) layer. We see 3 groups belonging to 1 panel:

```{r}
layer_data(p, 1)[c("PANEL", "group")]
```

We use the `ggtrace_inspect_n()` function from `ggtrace()` to confirm that these _compute_ methods are called once per layer/panel/group of our bar plot:

```{r}
ggtrace_inspect_n(x = p, method = Stat$compute_layer) # Inherited from `Stat`
ggtrace_inspect_n(x = p, method = Stat$compute_panel) # Inherited from `Stat`
ggtrace_inspect_n(x = p, method = StatCount$compute_group) # Defined in `StatCount`
```

And what do these methods return?

Let's first inspect the output of `StatCount$compute_group` each time it is called using the function `ggtrace_inspect_return()` from the `{ggtrace}` package:^[The `cond` argument takes an expression to be evaluated to TRUE/FALSE inside of the method's execution environment. The `._counter_` variable is an internal variable that `ggtrace_*` functions updates to keep track of how many times the method has been called so far. You can read more in the [Tracing context section](https://yjunechoe.github.io/ggtrace/reference/ggtrace_inspect_return.html#tracing-context) of the docs. ]

```{r}
list(
  ggtrace_inspect_return(p, StatCount$compute_group, cond = quote(._counter_ == 1)),
  ggtrace_inspect_return(p, StatCount$compute_group, cond = quote(._counter_ == 2)),
  ggtrace_inspect_return(p, StatCount$compute_group, cond = quote(._counter_ == 3))
)
```

Then, the output of `Stat$compute_panel` for the one panel that exists in our bar layer:

```{r}
ggtrace_inspect_return(x = p, method = Stat$compute_panel)
```

And finally, the output of `Stat$compute_layer` for the entire bar layer:

```{r}
ggtrace_inspect_return(x = p, method = Stat$compute_layer)
```

To sum up, the `compute_layer` method splits up the data by _panel_ and calls the `compute_panel` method for each panel, at which point the `compute_panel` method splits up the data by _group_ and calls `compute_group` for each group.

In fact, this split-combine-apply design of the compute methods is how `StatCount` can get away with overriding just the `compute_group` method of the parent `Stat` ggproto: the narrower `compute_group` method calculates new variables at the group-level, while the `compute_panel` and `compute_layer` methods just do their default job of combining information about each group (binding rows, basically).

And this is precisely how the `Stat` ggproto is designed - it defines generic `compute_layer` and `compute_panel` methods that do the _split_ and _combine_, but the actual _apply_ step is reserved for the `compute_group` method.^[But sometimes, child Stats may override a compute method at a higher level. For example, `StatSummary` overrides `compute_panel` to do the _apply_ step there, by panel, and does not pass data down to `compute_group` at all. Another (extreme) example is `StatIdentity` which rewrites `compute_layer` to just return the data as it received it, without passing it down to `compute_panel`/`compute_group`.] In fact, we find that `Stat$compute_group` is actually just a placeholder:

```{r}
get_method(Stat$compute_group)
```

### 3. Inspecting `StatCount$compute_group`

Okay, so let's return to `StatCount`: what exactly does `StatCount$compute_group` _do_?

```{r}
get_method(StatCount$compute_group)
```

It looks like a pretty standard function, and it's clear now how `count` gets defined. In Steps 5-7, a new variable called `count` is created, then its `NA`s are handled by being turned into `0`, and then the variable is added to a new dataframe that gets returned at the end:

```{r}
ggbody(StatCount$compute_group)[5:7]
```

Once we strip ggplot internals down to the basics, it's now starting to look like good ol' functional programming!

But we still can't quite interact with it. The tricky part of ggproto methods is that they often take obligatory arguments that are only available internally, like `scales` which is an object that contains information about the x/y-scales of the plot.

One work-around is to use the `ggtrace_capture_fn()` from the `{ggtrace}` package, which returns a snapshot of a ggproto method when it was called (when it was _first_ called, by default):

```{r}
StatCount_compute_group_1 <- ggtrace_capture_fn(
  x = p,
  method = StatCount$compute_group
)
```

The body of the captured function is the same as the ggproto method itself:

```{r}
identical(
  body(StatCount_compute_group_1),
  ggbody(StatCount$compute_group, as.list = FALSE)
)
```

But what makes this captured function special is that it is **pre-filled** with the value of its arguments when it was called. This allows `StatCount_compute_group_1` to just be called as-is.

```{r}
StatCount_compute_group_1()
```

The arguments of the captured functions can be inspected with the `formals()` function. There's quite a bit of info in there so it's collapsed below and you can just take what you need:

<details>
<summary>Captured argument values for `StatCount$compute_group`</summary>
```{r}
formals(StatCount_compute_group_1)
```
</details>

But just to make the "functional programming" aspect of this a bit more transparent, the input data looks like this:

```{r}
rmarkdown::paged_table(formals(StatCount_compute_group_1)$data)
```

And the output data looks like this:

```{r}
StatCount_compute_group_1()
```

It just boils down to `group_by()` + `sumarize()` !

### 4. Wrapping up

So far, we have discovered the following about the output of `StatCount$compute_group`:

- The `count` column is calculated from `data$x` and `data$weight` (if it exists)
- The `prop` column is derived from `count`
- The `x` column is the unique values of `x` from the input `data`

The last piece of the puzzle are the `width` and `flipped_aes` columns. These are actually straightforward - they are parameters first passed into `Stat$compute_layer` and then passed down to the other compute methods from there. When `StatCount$compute_group` receives them, it uses that information to inform how it should transform the data (here, they're just added as columns).

As such, `width` and `flipped_aes` exist in the formals of our captured function from above:

```{r}
formals(StatCount_compute_group_1)[c("width", "flipped_aes")]
```

If you're wondering about their origin, they're retrieved/calculated in the `StatCount$setup_params` method. If you're interested you can open the details below, but it's not critical information for moving forward.

<details>
<summary>`StatCount$setup_params`</summary>
`StatCount$setup_params`, is another Stat method that's called in an earlier step of `Layer$compute_statistic` .

It's called in Step 3, and the output is assigned to `self$computed_stat_params`:

```{r}
ggbody(ggplot2:::Layer$compute_statistic)[[3]]
```

`self$computed_stat_params` is then passed in as an argument to `self$stat$compute_layer` in the last step:

```{r}
ggbody(ggplot2:::Layer$compute_statistic)[[5]]
```

When we look inside `StatCount$setup_params`, we see that `width` defaults to 0.9 and `flipped_aes` is computed from the internal function `ggplot2:::has_flipped_aes()` which figures out whether a layer is "flipped" (from setting `orientation = "y"` inside `geom_bar()`, for example)

```{r}
get_method(StatCount$setup_params)
```
</details>

So there we have it! Hopefully this provides a better sense of what was happening at the step inside `ggplot_build()` which added the `count` column in the dataframe representation of our bar layer. The relevant line of code is repeated again below:

```{r}
ggbody(ggplot2:::ggplot_build.ggplot)[[18]]
```

Next, let's explore _how_ this new `count` variable got mapped to the `y` aesthetic. We never said anything about the `y` when we created our bar plot, so how does ggplot know what to do?

## The _How_ - delayed aesthetic mapping

Recall that Step 19 of `ggplot_build()` was responsible for the changing the data such that a new column `y` was added with the same value as `count`, as detected in Step 20:

```{r}
internal_data_transformations$Step20
```

The line of code responsible for this was the following:

```{r}
ggbody(ggplot2:::ggplot_build.ggplot)[[19]]
```

We won't do another dive into the implementational details here because it involves some complicated metaprogramming. It suffices to know that the mapping of the variable `count` calculated by the Stat to the aesthetic `y` is handled by the `Layer$map_statistic` method.

Let's instead focus on the higher-level question of how ggplot knew that it should first _wait_ after the Stat has transformed the data and then map the new `count` variable to `y`.

The answer, as you might have guessed, is `after_stat()`! This function takes one argument `x` which is captured as an expression, to be evaluated _after the Stat has stepped in and transformed the data_.

So in our case, the fact that `count` is mapped to `y` after the stat gets applied suggests that `y` is mapped to `after_stat(count)`. And indeed this is the case, as we can see from the `default_aes` property of `StatCount`, where default values for aesthetic mappings are specified:

```{r}
StatCount$default_aes
```

Note that both `x` and `y` are mapped to `after_stat(count)` by default. It might seem odd, but you can appreciate its clever design when you see it in conjunction with the `required_aes` property of `StatCount`, where mandatory aesthetic mappings are specified in regex syntax:

```{r}
# `|` operator in regex means "or"
StatCount$required_aes
```

Basically, `required_aes` forces the user to override the aesthetic mapping for either `x` or `y`, which naturally leads to the other defaulting to `after_stat(count)`. Neat!

So to go back to our plot, there was an implicit `aes(y = after_stat(count))` all along, which we now make explicit here:

```{r}
ggplot(penguins) +
  aes(x = species) +
  aes(fill = species) +
  geom_bar(aes(y = after_stat(count)))
```

The expression inside `after_stat()` is evaluated in what's called a [**data-masked** context](https://rlang.r-lib.org/reference/topic-data-mask.html), much like `aes()` or `{dplyr}` verbs like `mutate()` and `summarize()`. This is why you can just refer to `count` as if it were a variable name and `after_stat()` will grab that column vector from the data transformed by the stat.

Let's test this hypothesis out with an example output from the stat, again using `ggtrace_inspect_return()` on `Stat$compute_layer`:

```{r}
ggtrace_inspect_return(p, Stat$compute_layer)
```

All of these variables should theoretically be accessible by `after_stat()`, and indeed this is the case. Here we map `y` to each variable in the data after the Stat transformation, converting to numeric as needed to conform to the plot's continuous y scale.

```{r, out.width="50%", fig.show='hold'}
# Plots are printed left -> right and top -> bottom
# in order of `matrix(1:8, ncol = 2, byrow = TRUE)`
p + aes(y = after_stat(count))
p + aes(y = after_stat(prop))
p + aes(y = after_stat(x))
p + aes(y = after_stat(width))
p + aes(y = after_stat(as.numeric(flipped_aes)))
p + aes(y = after_stat(nchar(as.character(fill))))
p + aes(y = after_stat(as.numeric(PANEL)))
p + aes(y = after_stat(group))
```

Before I get sacked, I should add that just because you _can_, doesn't mean you _should_! But hopefully this is a clear demonstration of the point that `after_stat()` gives you access to columns from the data after it has been transformed by the Stat.

#### Another practice with computed variable `prop`

Let's quickly look at another example. You might have noticed how the new `prop` column that's added to the data by `StatCount` has just been 1, which isn't too useful. What is `prop` and when does it ever take on a different value?

If you look at the documentation for `geom_bar()` under the section "Computed variables", you will see the following descriptions for the two computed variables `count` and `prop`:

- **count**: number of points in the bin
- **prop**: groupwise proportion

The value of `prop` was 1 in our previous plot because each bar was assigned a unique `group`, so `StatCount$compute_group` was only ever computing over 1-row data.

If we wanted to change that, we'd need to specify an explicit grouping that creates fewer groups than the number of bars (i.e., the interaction of all discrete variables).

In this example, we make `geom_bar()` make a bar for each category of `species` as mapped to `x`, but internally represent the three bars as belonging to two groups: 

```{r}
p_bar_prop <- ggplot(penguins) +
  geom_bar(aes(x = species, group = species == "Adelie"))
p_bar_prop
```

It doesn't _look_ like there are two groups underlyingly, but let's see what happens when we inspect the data transformed by the Stat:

```{r}
ggtrace_inspect_return(p_bar_prop, Stat$compute_layer)
```

We see only two groups, and where we have two bars (rows) belonging to the same group, the values of `prop` add up to 1!

Our `p_bar_prop` has grey fill for all bars that make its grouping structure ambiguous, but this was for expository purposes only. If we wanted to fill the bars by group, we could do it in at least two ways.

A hacky way that is 100% not recommended but possible is to mark the groupings post-hoc, by grabbing the `group` variable in the `after_stat()` and mapping that to something like `fill`:

```{r}
p_bar_prop +
  aes(fill = after_stat(as.factor(group)))
```

But not only does this hacky post-hoc way add unnecessary steps, it's also dangerous because of the use of the `aes()` to map a `after_stat()` variable _globally_. You should avoid this because different layers can have different stats, so the same computed variable can have different values and mean different things across layers, which can lead to some surprising behavior like this:^[The label geom, by virtue of not having any groupings specified, is assigned a group value of -1 (see `ggplot2:::NO_GROUP`). This introduces another group category to the pre-existing groups 1 and 2 created by the bar layer, and so this has consequences for when the fill scale steps in to derive values of `fill` from the levels of `group`. ]

```{r}
p_bar_prop +
  aes(fill = after_stat(as.factor(group))) +
  geom_label(aes(x = 2, y = 100, label = "Hello"), stat = "unique")
```

A safer, more principled way is to go back inside the `aes()` for the bar layer and visually mark the underlying grouping for the bars with a non-positional discrete aesthetic, like `fill`:

```{r}
p_bar_group_fill <- ggplot(penguins) +
  geom_bar(
    aes(
      x = species,
      group = species == "Adelie",
      fill = species == "Adelie"
    )
  )
p_bar_group_fill
```

For a quick experiment, note what happens if you only map `species == "Adelie"` to `fill`:

```{r}
p_bar_only_fill <- ggplot(penguins) +
  geom_bar(
    aes(
      x = species,
      # group = species == "Adelie",
      fill = species == "Adelie"
    )
  )
p_bar_only_fill
```

The two look the same where `count` is concerned, but notice that `prop` is calculated differently:

```{r, out.width="50%", fig.show='hold'}
p_bar_group_fill + aes(y = after_stat(prop))
p_bar_only_fill + aes(y = after_stat(prop))
```

As you might have guessed, this is because the underlying grouping structure is different:^[Note also how `group` appears in different column positions. When `group` is explicitly supplied, it appears to the **left** of `PANEL`, and when `group` is derived it appears to the **right** of `PANEL`. Where and how does this happen? I'll leave this question as an exercise (hint: look at `Layer$compute_aesthetics` and `ggplot2:::add_group()`). ]

```{r}
ggtrace_inspect_return(p_bar_group_fill, Stat$compute_layer)
ggtrace_inspect_return(p_bar_only_fill, Stat$compute_layer)
```

**Section Fin.**

## Another practice: `geom_boxplot()`

## `after_scale()` and usecases

## `stage()` and hacks

```{r}
ggplot(mtcars, aes(as.factor(cyl), mpg)) +
  stat_boxplot(
    aes(
      y = stage(mpg, after_stat = middle),
      ymin = after_stat(lower),
      ymax = after_stat(upper)
    ),
    geom = GeomPointrange,
    position = position_identity()
  )
```
